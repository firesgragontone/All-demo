

Base64 有三个字符`+`、`/`和`=`，在 URL 里面有特殊含义，所以要被替换掉：`=`被省略、`+`替换成`-`，`/`替换成`_` 。这就是 Base64URL 算法。



```java 
@Pointcut("@annotation(com.csci.china.zhongdeng.common.annotation.DownloadExceptionHandler) || @within(com.csci.china.zhongdeng.common.annotation.DownloadExceptionHandler)")
public void cut() {
}
@annotation和@wihin配合使用 
```

```java
通过HttpContext可以获取request的各项参数
    包括url,自定义参数，header,sign,businesskey
HttpServletRequest request = HttpContext.getRequest();
StringBuffer url = request.getRequestURL();
String path = URLUtil.getPath(String.valueOf(url));
String timestamp = request.getHeader(RequestHeaderKeyConstant.TIMESTAMP_HEADER_KEY);
String businessKey = request.getHeader(RequestHeaderKeyConstant.BUSINESS_KEY_HEADER_KEY);
String sign = request.getHeader(RequestHeaderKeyConstant.SIGN_HEADER_KEY);

```

```java 
public class CoreException extends RuntimeException{}



```



```
xml转为Java
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "login", propOrder = {
    "userName",
    "userPassword",
    "platformAuthCode"
})
```

```
log.info("sign info :{},{},{}",url,timestamp,sign);
```

1.花里胡哨的springboot开局

springboot项目的resources文件夹下面创建一个banner.txt文件，springboot启动的时候会去加载这个文件

2.依赖冲突

关于依赖冲突解决方式有三种：最短路径原则、声明优先原则、依赖排除。在没有手动进行依赖排除的情况下，会依据最短路径原则、声明优先原则来选择jar包。关于依赖冲突排查可借助如maven-enforcer-plugin 与Maven Helper 插件。





```java
Java自带缓存机制
    同样的请求时回去spring的缓存池中提取缓存的数据
@CacheEvict(value = "appAuthorization:getOneByBusinessKey:", key = "#businessKey")
```

```java
文件流写出
byte[] b = new byte[1024];
int len;
while ((len = imageStream.read(b, 0, 1024)) != -1) {
    response.getOutputStream().write(b, 0, len);
}
response.getOutputStream().flush();
```



```java
整形包装类输出格式设置
BigDecimal bd = new BigDecimal(1000000);
DecimalFormat df = new DecimalFormat("#,##0.00");
String formatAmount = df.format(bd);
System.out.println(formatAmount);
```



```
 &lt;
```

```java
                //分页
                    resultVO.setTotal((long)data.size());
                    int skipNum = form.getLimit() * (form.getPage() - 1);
                    data = data.stream().skip(skipNum).limit(form.getLimit()).collect(Collectors.toList());
```

